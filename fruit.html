<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Falling fruits — clean & simple</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --ui-font: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    html,body { height:100%; margin:0; font-family: var(--ui-font); }
    /* Fullscreen canvas for Matter renderer. pointer-events:none so page text remains interactive. */
    #stage { position:fixed; left:0; top:0; width:100%; height:100%; pointer-events:none; display:block; }
    .content { padding:36px; max-width:900px; margin:0 auto; line-height:1.7; position:relative; z-index:1; }
    .fruit-word {
      color:#1a73e8;
      cursor:pointer;
      text-decoration:underline;
      pointer-events:auto; /* words should receive clicks even though canvas covers page */
    }
  </style>
</head>
<body>
  <canvas id="stage"></canvas>

  <div class="content">
    <h1>Click a word to spawn fruit!</h1>
    <p>
      Click any of these: 
      <span class="fruit-word" data-fruit="apple">apple</span>,
      <span class="fruit-word" data-fruit="orange">orange</span>,
      <span class="fruit-word" data-fruit="pear">pear</span>,
      <span class="fruit-word" data-fruit="banana">banana</span>.
      Fruits fall from the top and remain on the page until you refresh or leave.
    </p>
    <p>Rapid clicking is supported — each click creates a new physics body.</p>
  </div>

  <!-- Matter.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

  <script>
  (function () {
    // Matter aliases for convenience
    const { Engine, Render, Runner, Bodies, Body, Composite } = Matter;

    // ----------------------
    // Engine & renderer
    // ----------------------
    // enableSleeping: true (original/simple behavior)
    const engine = Engine.create();
    engine.world.gravity.y = 1.1; // gravity strength (tweak to taste)
    const canvas = document.getElementById('stage');

    // Create the renderer (full-screen canvas). We keep one Render instance.
    const render = Render.create({
      canvas: canvas,
      engine: engine,
      options: {
        width: window.innerWidth,
        height: window.innerHeight,
        background: 'transparent',
        wireframes: false,
        pixelRatio: window.devicePixelRatio || 1
      }
    });
    Render.run(render);

    // Runner
    const runner = Runner.create();
    Runner.run(runner, engine);

    // Invisible bounds (floor + left/right walls)
    const worldBounds = Matter.Bounds.create([
        { x: 0, y: 0 },
        { x: window.innerWidth, y: 0 },
        { x: window.innerWidth, y: window.innerHeight },
        { x: 0, y: window.innerHeight }
    ]);

    const thickness = 200;
    const { min, max } = worldBounds;

    const floor = Bodies.rectangle(
        (min.x + max.x) / 2, max.y + thickness / 2,
        max.x - min.x + thickness * 2, thickness,
        { isStatic: true, render: { visible: false } }
    );

    Composite.add(engine.world, floor);
    
    // ----------------------
    // Fruit definitions
    // Keep these small and easy to tweak.
    // ----------------------
    const FRUITS = {
      apple: {
        type: 'circle',
        radius: 20,
        options: { density: 0.002, friction: 0.6, restitution: 0.1, render: { fillStyle: '#e53935' } }
      },
      orange: {
        type: 'circle',
        radius: 18,
        options: { density: 0.002, friction: 0.55, restitution: 0.15, render: { fillStyle: '#fb8c00' } }
      },
      pear: {
        type: 'polygon',
        // simple vertex shape approximating a pear
        vertices: [{x:-14,y:-18},{x:14,y:-18},{x:22,y:0},{x:8,y:24},{x:-8,y:24},{x:-22,y:0}],
        options: { density: 0.002, friction: 0.6, restitution: 0.08, render: { fillStyle: '#8bc34a' } }
      },
      banana: {
        type: 'polygon',
        // convex-ish banana approximation
        vertices: [{x:-26,y:-6},{x:-18,y:-14},{x:-6,y:-20},{x:6,y:-18},{x:18,y:-10},{x:22,y:0},{x:12,y:8},{x:-6,y:12},{x:-20,y:8}],
        options: { density: 0.0018, friction: 0.5, restitution: 0.12, render: { fillStyle: '#ffeb3b' } }
      }
    };

    let nextId = 1; // unique id for labeling bodies
    function createFruitBody(kind) {
      const spec = FRUITS[kind]
      let body;

      if (spec.type === 'circle') {
        body = Bodies.circle(-100, -100, spec.radius, Object.assign({}, spec.options));
      } else if (spec.type === 'polygon') {
        // Matter.fromVertices will attempt to create a compound if needed
        const verts = spec.vertices.map(v => ({ x: v.x, y: v.y }));
        body = Bodies.fromVertices(-100, -100, verts, Object.assign({}, spec.options), true);
        // fallback to rectangle if fromVertices fails
        if (!body) {
          body = Bodies.rectangle(-100, -100, 40, 40, Object.assign({}, spec.options));
        }
      } else {
        body = Bodies.circle(-100, -100, 20, Object.assign({}, spec.options));
      }

      body.label = `fruit-${kind}-${nextId++}`;
      body.customKind = kind;
      body.render.strokeStyle = '#333';
      body.render.lineWidth = 1;
      // mark so we can identify fruit bodies later if needed
      body.isFruit = true;
      return body;
    }

    function spawnFruit(kind, screenX) {
      const body = createFruitBody(kind);

      // place above the top of the viewport with a small random offset
      const spawnX = Math.max(20, Math.min(window.innerWidth - 20, screenX + (Math.random() - 0.5) * 40));
      const spawnY = -40 - Math.random() * 60;
      Body.setPosition(body, { x: spawnX, y: spawnY });

      // small lateral velocity + angular velocity
      Body.setVelocity(body, { x: (Math.random() - 0.5) * 3, y: 0});
      Body.setAngularVelocity(body, (Math.random() - 0.5) * 0.6);

      // small random force nudge so newly created bodies don't perfectly overlap
      const push = 0.0006 + Math.random() * 0.0006;
      Body.applyForce(body, { x: spawnX, y: spawnY }, { x: (Math.random() - 0.5) * push, y: -push * 0.2 });

      Composite.add(engine.world, body);
      return body;
    }

    document.addEventListener('click', function (e) {
        const el = e.target.closest('.fruit-word');
        const kind = el.dataset.fruit || 'apple';
        spawnFruit(kind, window.innerWidth / 2);
    });


    window.addEventListener('resize', () => { 
        Matter.Bounds.update(worldBounds, [
            { x: 0, y: 0 },
            { x: window.innerWidth, y: 0 },
            { x: window.innerWidth, y: window.innerHeight },
            { x: 0, y: window.innerHeight }
        ]);
        const { min, max } = worldBounds;
        Body.setPosition(floor, { x: (min.x + max.x) / 2, y: max.y + thickness / 2 });
        Body.setPosition(leftWall, { x: min.x - thickness / 2, y: (min.y + max.y) / 2 });
        Body.setPosition(rightWall, { x: max.x + thickness / 2, y: (min.y + max.y) / 2 });
    });

  })();
  </script>
</body>
</html>
